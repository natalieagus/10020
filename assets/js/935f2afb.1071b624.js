"use strict";(self.webpackChunksite_docusaurus_template=self.webpackChunksite_docusaurus_template||[]).push([[53],{1109:e=>{e.exports=JSON.parse('{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"tutorialSidebar":[{"type":"link","label":"Syllabus","href":"/10020/notes/introduction","docId":"introduction"},{"type":"category","label":"Sorting Algorithms","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Bubble Sort","href":"/10020/notes/sorting-algorithms/bubble-sort","docId":"sorting-algorithms/bubble-sort"},{"type":"link","label":"Insertion Sort","href":"/10020/notes/sorting-algorithms/insertion-sort","docId":"sorting-algorithms/insertion-sort"},{"type":"link","label":"Binary Heap","href":"/10020/notes/sorting-algorithms/binary-heap","docId":"sorting-algorithms/binary-heap"},{"type":"link","label":"Heapsort","href":"/10020/notes/sorting-algorithms/heapsort","docId":"sorting-algorithms/heapsort"}],"href":"/10020/notes/category/sorting-algorithms"},{"type":"link","label":"Computation Time","href":"/10020/notes/computation-time","docId":"computation-time"},{"type":"category","label":"Divide and Conquer","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Recursion","href":"/10020/notes/divide-and-conquer/divide-and-conquer","docId":"divide-and-conquer/divide-and-conquer"},{"type":"link","label":"Merge Sort","href":"/10020/notes/divide-and-conquer/merge-sort","docId":"divide-and-conquer/merge-sort"}],"href":"/10020/notes/category/divide-and-conquer"},{"type":"category","label":"OOP","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Object Oriented Programming","href":"/10020/notes/oop/oop","docId":"oop/oop"},{"type":"link","label":"Linear Data Structures","href":"/10020/notes/oop/linear-dt","docId":"oop/linear-dt"}],"href":"/10020/notes/category/oop"},{"type":"category","label":"Graph Theory","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Basics of Graph","href":"/10020/notes/graphs/basics-graph","docId":"graphs/basics-graph"},{"type":"link","label":"Breadth First Search","href":"/10020/notes/graphs/bfs","docId":"graphs/bfs"},{"type":"link","label":"Depth First Search","href":"/10020/notes/graphs/dfs","docId":"graphs/dfs"}],"href":"/10020/notes/category/graph-theory"},{"type":"category","label":"Class Inheritance","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Inheritance","href":"/10020/notes/oop/inheritance-abc","docId":"oop/inheritance-abc"},{"type":"link","label":"Fixed-Size Array and Linked List","href":"/10020/notes/oop/array-linkedlist","docId":"oop/array-linkedlist"}],"href":"/10020/notes/category/class-inheritance"},{"type":"category","label":"Data Visualisation","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Working With Data","href":"/10020/notes/data-visualization/working-width-data","docId":"data-visualization/working-width-data"},{"type":"link","label":"Visualization","href":"/10020/notes/data-visualization/visualisation","docId":"data-visualization/visualisation"}],"href":"/10020/notes/category/data-visualisation"}]},"docs":{"computation-time":{"id":"computation-time","title":"Computation Time","description":"Computation time, also known as runtime or execution time, refers to the amount of time taken by a computer program or algorithm to complete its execution, typically measured in seconds or milliseconds.","sidebar":"tutorialSidebar"},"data-visualization/visualisation":{"id":"data-visualization/visualisation","title":"Visualization","description":"Goals","sidebar":"tutorialSidebar"},"data-visualization/working-width-data":{"id":"data-visualization/working-width-data","title":"Working With Data","description":"Goals","sidebar":"tutorialSidebar"},"divide-and-conquer/divide-and-conquer":{"id":"divide-and-conquer/divide-and-conquer","title":"Recursion","description":"Goals","sidebar":"tutorialSidebar"},"divide-and-conquer/merge-sort":{"id":"divide-and-conquer/merge-sort","title":"Merge Sort","description":"Merge Sort is another sorting algorithm that implements the principle of divide and conquer.","sidebar":"tutorialSidebar"},"graphs/basics-graph":{"id":"graphs/basics-graph","title":"Basics of Graph","description":"Goals","sidebar":"tutorialSidebar"},"graphs/bfs":{"id":"graphs/bfs","title":"Breadth First Search","description":"Breadth-first search is a graph traversal algorithm that explores all the vertices of a graph at the same level before moving to the next level, ensuring the shortest path to each vertex is discovered first.","sidebar":"tutorialSidebar"},"graphs/dfs":{"id":"graphs/dfs","title":"Depth First Search","description":"Depth First Search is a graph traversal algorithm that explores as far as possible along each branch before backtracking.","sidebar":"tutorialSidebar"},"introduction":{"id":"introduction","title":"Syllabus","description":"This page summarises the links to all notes that are relevant to 10.020. Please read them carefully by the weeks stipulated. You will learn each of the big topics above in the following weeks:","sidebar":"tutorialSidebar"},"oop/array-linkedlist":{"id":"oop/array-linkedlist","title":"Fixed-Size Array and Linked List","description":"In this lesson we will detour a little bit to discuss two kinds of list. One is a Fixed Size Array and the other one is a Linked List. Both are list but they have their differences.","sidebar":"tutorialSidebar"},"oop/inheritance-abc":{"id":"oop/inheritance-abc","title":"Inheritance","description":"In Python, inheritance in classes allows a child class to inherit and extend the attributes and methods of a parent class.","sidebar":"tutorialSidebar"},"oop/linear-dt":{"id":"oop/linear-dt","title":"Linear Data Structures","description":"A linear data structure is a collection of elements where each element has a direct successor and predecessor, forming a sequential arrangement.","sidebar":"tutorialSidebar"},"oop/oop":{"id":"oop/oop","title":"Object Oriented Programming","description":"Object-oriented programming is a programming paradigm that organizes code into objects, which encapsulate data and behavior, fostering modularity, reusability, and easier maintenance of software systems.","sidebar":"tutorialSidebar"},"sorting-algorithms/binary-heap":{"id":"sorting-algorithms/binary-heap","title":"Binary Heap","description":"Binary heap is a complete binary tree-based data structure that satisfies the heap property, where the key of each parent node is either greater than or equal to (in a max heap) or less than or equal to (in a min heap) the keys of its child nodes.","sidebar":"tutorialSidebar"},"sorting-algorithms/bubble-sort":{"id":"sorting-algorithms/bubble-sort","title":"Bubble Sort","description":"Bubble sort is a simple comparison-based sorting algorithm that repeatedly swaps adjacent elements until the list is sorted.","sidebar":"tutorialSidebar"},"sorting-algorithms/heapsort":{"id":"sorting-algorithms/heapsort","title":"Heapsort","description":"Heapsort is a comparison-based sorting algorithm that builds a binary heap data structure and repeatedly extracts the maximum element to sort a given array.","sidebar":"tutorialSidebar"},"sorting-algorithms/insertion-sort":{"id":"sorting-algorithms/insertion-sort","title":"Insertion Sort","description":"Insertion sort is a comparison-based sorting algorithm that builds the final sorted array one element at a time by inserting each element into its correct position within the already sorted portion of the array.","sidebar":"tutorialSidebar"}}}')}}]);