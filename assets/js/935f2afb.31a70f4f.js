"use strict";(self.webpackChunksite_docusaurus_template=self.webpackChunksite_docusaurus_template||[]).push([[53],{1109:e=>{e.exports=JSON.parse('{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"tutorialSidebar":[{"type":"link","label":"Syllabus","href":"/10020/notes/introduction","docId":"introduction"},{"type":"category","label":"Sorting Algorithms","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Bubble Sort","href":"/10020/notes/sorting-algorithms/bubble-sort","docId":"sorting-algorithms/bubble-sort"},{"type":"link","label":"Insertion Sort","href":"/10020/notes/sorting-algorithms/insertion-sort","docId":"sorting-algorithms/insertion-sort"},{"type":"link","label":"Binary Heap","href":"/10020/notes/sorting-algorithms/binary-heap","docId":"sorting-algorithms/binary-heap"},{"type":"link","label":"Heapsort","href":"/10020/notes/sorting-algorithms/heapsort","docId":"sorting-algorithms/heapsort"}],"href":"/10020/notes/category/sorting-algorithms"},{"type":"link","label":"Computation Time","href":"/10020/notes/computation-time","docId":"computation-time"},{"type":"category","label":"Divide and Conquer","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Recursion","href":"/10020/notes/divide-and-conquer/divide-and-conquer","docId":"divide-and-conquer/divide-and-conquer"},{"type":"link","label":"Merge Sort","href":"/10020/notes/divide-and-conquer/merge-sort","docId":"divide-and-conquer/merge-sort"}],"href":"/10020/notes/category/divide-and-conquer"},{"type":"category","label":"OOP","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Object Oriented Programming","href":"/10020/notes/oop/oop","docId":"oop/oop"},{"type":"link","label":"Linear Data Structures","href":"/10020/notes/oop/linear-dt","docId":"oop/linear-dt"}],"href":"/10020/notes/category/oop"},{"type":"category","label":"Graph Theory","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Basics of Graph","href":"/10020/notes/graphs/basics-graph","docId":"graphs/basics-graph"},{"type":"link","label":"Breadth First Search","href":"/10020/notes/graphs/bfs","docId":"graphs/bfs"},{"type":"link","label":"Depth First Search","href":"/10020/notes/graphs/dfs","docId":"graphs/dfs"}],"href":"/10020/notes/category/graph-theory"},{"type":"category","label":"Class Inheritance","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Inheritance","href":"/10020/notes/oop/inheritance-abc","docId":"oop/inheritance-abc"},{"type":"link","label":"Fixed-Size Array and Linked List","href":"/10020/notes/oop/array-linkedlist","docId":"oop/array-linkedlist"}],"href":"/10020/notes/category/class-inheritance"},{"type":"category","label":"Data Visualisation","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Working With Data","href":"/10020/notes/data-visualization/working-width-data","docId":"data-visualization/working-width-data"},{"type":"link","label":"Visualization","href":"/10020/notes/data-visualization/visualisation","docId":"data-visualization/visualisation"}],"href":"/10020/notes/category/data-visualisation"}]},"docs":{"computation-time":{"id":"computation-time","title":"Computation Time","description":"Computation time, also known as runtime or execution time, refers to the amount of time taken by a computer program or algorithm to complete its execution, typically measured in seconds or milliseconds.","sidebar":"tutorialSidebar"},"data-visualization/visualisation":{"id":"data-visualization/visualisation","title":"Visualization","description":"Data visualization using Matplotlib and Seaborn in Python enables the creation of informative and visually appealing plots, charts, and graphs, facilitating the exploration, understanding, and communication of patterns, trends, and insights within data.","sidebar":"tutorialSidebar"},"data-visualization/working-width-data":{"id":"data-visualization/working-width-data","title":"Working With Data","description":"Python Pandas is a powerful open-source library that provides high-performance data structures and data analysis tools, making it a popular choice for data manipulation, cleaning, analysis, and visualization tasks.","sidebar":"tutorialSidebar"},"divide-and-conquer/divide-and-conquer":{"id":"divide-and-conquer/divide-and-conquer","title":"Recursion","description":"Recursion is a programming technique in which a function calls itself to solve a problem by breaking it down into smaller subproblems.","sidebar":"tutorialSidebar"},"divide-and-conquer/merge-sort":{"id":"divide-and-conquer/merge-sort","title":"Merge Sort","description":"Merge Sort is another sorting algorithm that implements the principle of divide and conquer.","sidebar":"tutorialSidebar"},"graphs/basics-graph":{"id":"graphs/basics-graph","title":"Basics of Graph","description":"Graph theory is a mathematical discipline that studies the properties and relationships of graphs, which consist of nodes (vertices) connected by edges, enabling analysis of various real-world systems and phenomena.","sidebar":"tutorialSidebar"},"graphs/bfs":{"id":"graphs/bfs","title":"Breadth First Search","description":"Breadth-first search is a graph traversal algorithm that explores all the vertices of a graph at the same level before moving to the next level, ensuring the shortest path to each vertex is discovered first.","sidebar":"tutorialSidebar"},"graphs/dfs":{"id":"graphs/dfs","title":"Depth First Search","description":"Depth First Search is a graph traversal algorithm that explores as far as possible along each branch before backtracking.","sidebar":"tutorialSidebar"},"introduction":{"id":"introduction","title":"Syllabus","description":"This page summarises the links to all notes that are relevant to 10.020. Please read them carefully by the weeks stipulated. You will learn each of the big topics above in the following weeks:","sidebar":"tutorialSidebar"},"oop/array-linkedlist":{"id":"oop/array-linkedlist","title":"Fixed-Size Array and Linked List","description":"In this lesson we will detour a little bit to discuss two kinds of list. One is a Fixed Size Array and the other one is a Linked List. Both are list but they have their differences.","sidebar":"tutorialSidebar"},"oop/inheritance-abc":{"id":"oop/inheritance-abc","title":"Inheritance","description":"In Python, inheritance in classes allows a child class to inherit and extend the attributes and methods of a parent class.","sidebar":"tutorialSidebar"},"oop/linear-dt":{"id":"oop/linear-dt","title":"Linear Data Structures","description":"A linear data structure is a collection of elements where each element has a direct successor and predecessor, forming a sequential arrangement.","sidebar":"tutorialSidebar"},"oop/oop":{"id":"oop/oop","title":"Object Oriented Programming","description":"Object-oriented programming is a programming paradigm that organizes code into objects, which encapsulate data and behavior, fostering modularity, reusability, and easier maintenance of software systems.","sidebar":"tutorialSidebar"},"sorting-algorithms/binary-heap":{"id":"sorting-algorithms/binary-heap","title":"Binary Heap","description":"Binary heap is a complete binary tree-based data structure that satisfies the heap property, where the key of each parent node is either greater than or equal to (in a max heap) or less than or equal to (in a min heap) the keys of its child nodes.","sidebar":"tutorialSidebar"},"sorting-algorithms/bubble-sort":{"id":"sorting-algorithms/bubble-sort","title":"Bubble Sort","description":"Bubble sort is a simple comparison-based sorting algorithm that repeatedly swaps adjacent elements until the list is sorted.","sidebar":"tutorialSidebar"},"sorting-algorithms/heapsort":{"id":"sorting-algorithms/heapsort","title":"Heapsort","description":"Heapsort is a comparison-based sorting algorithm that builds a binary heap data structure and repeatedly extracts the maximum element to sort a given array.","sidebar":"tutorialSidebar"},"sorting-algorithms/insertion-sort":{"id":"sorting-algorithms/insertion-sort","title":"Insertion Sort","description":"Insertion sort is a comparison-based sorting algorithm that builds the final sorted array one element at a time by inserting each element into its correct position within the already sorted portion of the array.","sidebar":"tutorialSidebar"}}}')}}]);